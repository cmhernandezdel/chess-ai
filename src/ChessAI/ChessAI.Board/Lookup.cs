namespace ChessAI.Board;

internal class Lookup
{
    // first index is the position of the piece with 0 being a1 and 63 being h8
    // second index is the occupancy of the rank, with the outer squares not mattering
    // occupancy index = (occupancy >> ((square & ~7) + 1)) & 63

    // to fill these, we put the rook in a1 through h1, we don't care about a and h files
    // and we represent whether the square is occupied or not by a bit (0/1), in reverse,
    // so i.e., if the rook is on A1 and C is occupied and the rest blank, the attacks will be
    // on b and c, so it is 0000 (h to e) - 0110 (d to a), so 0x06.
    public readonly byte[][] FirstRankAttacks = new byte[8][]
    {
        new byte[] { 
            0xf7, 0x02, 0x06, 0x02, 0x0e, 0x02, 0x06, 0x02,
            0x1e, 0x02, 0x06, 0x02, 0x0e, 0x02, 0x06, 0x02,
            0x3e, 0x02, 0x06, 0x02, 0x0e, 0x02, 0x06, 0x02,
            0x1e, 0x02, 0x06, 0x02, 0x0e, 0x02, 0x06, 0x02,
            0x7e, 0x02, 0x06, 0x02, 0x0e, 0x02, 0x06, 0x02,
            0x1e, 0x02, 0x06, 0x02, 0x0e, 0x02, 0x06, 0x02,
            0x3e, 0x02, 0x06, 0x02, 0x0e, 0x02, 0x06, 0x02,
            0x1e, 0x02, 0x06, 0x02, 0x0e, 0x02, 0x06, 0x02
        },
        new byte[] {
            0xfd, 0xfd, 0x05, 0x05, 0x0d, 0x0d, 0x05, 0x05,
            0x1d, 0x1d, 0x05, 0x05, 0x0d, 0x0d, 0x05, 0x05,
            0x3d, 0x3d, 0x05, 0x05, 0x0d, 0x0d, 0x05, 0x05,
            0x1d, 0x1d, 0x05, 0x05, 0x0d, 0x0d, 0x05, 0x05,
            0x7d, 0x7d, 0x05, 0x05, 0x0d, 0x0d, 0x05, 0x05,
            0x1d, 0x1d, 0x05, 0x05, 0x0d, 0x0d, 0x05, 0x05,
            0x3d, 0x3d, 0x05, 0x05, 0x0d, 0x0d, 0x05, 0x05,
            0x1d, 0x1d, 0x05, 0x05, 0x0d, 0x0d, 0x05, 0x05
        },
        new byte[] {
            0xfb, 0xfa, 0xfb, 0xfa, 0x0b, 0x0a, 0x0b, 0x0a,
            0x1b, 0x1a, 0x1b, 0x1a, 0x0b, 0x0a, 0x0b, 0x0a,
            0x3b, 0x3a, 0x3b, 0x3a, 0x0b, 0x0a, 0x0b, 0x0a,
            0x1b, 0x1a, 0x1b, 0x1a, 0x0b, 0x0a, 0x0b, 0x0a,
            0x7b, 0x7a, 0x7b, 0x7a, 0x0b, 0x0a, 0x0b, 0x0a,
            0x1b, 0x1a, 0x1b, 0x1a, 0x0b, 0x0a, 0x0b, 0x0a,
            0x3b, 0x3a, 0x3b, 0x3a, 0x0b, 0x0a, 0x0b, 0x0a,
            0x1b, 0x1a, 0x1b, 0x1a, 0x0b, 0x0a, 0x0b, 0x0a
        },
        new byte[] {},
        new byte[] {},
        new byte[] {},
        new byte[] {},
        new byte[] {},
    };
}
